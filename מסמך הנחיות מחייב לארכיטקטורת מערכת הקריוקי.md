### **חלק א': חוקי היסוד של המערכת (The Unbreakable Laws)**

1. **מקור אמת יחיד (Single Source of Truth):**  
   * **Elasticsearch** הוא מקור האמת היחיד והבלעדי עבור כל המטא-דאטה, הסטטוסים, ונתיבי הקבצים של השירים.  
   * כל שירות שזקוק למידע על שיר (למשל, מיקום קובץ) **חייב** לשלוף אותו מ-Elasticsearch באמצעות ה-video\_id.  
2.   
3. **תקשורת א-סינכרונית מוגבלת:**  
   * **Kafka** משמש **אך ורק** להעברת פקודות (Commands) ואירועים (Events) בין שירותים.  
   * הודעות Kafka **חייבות** להכיל רק מזהים (video\_id) ומידע מינימלי חיוני (כמו action).  
   * **אסור בתכלית האיסור** להעביר נתיבי קבצים (file\_path) דרך Kafka.  
4.   
5. **היררכיית תקשורת ברורה (HTTP Chain):**  
   * Streamlit Client מדבר **אך ורק** עם API Server ב-HTTP.  
   * API Server מדבר **אך ורק** עם YouTube Service ב-HTTP.  
   * שירותי העיבוד (Audio, Transcription) **אינם** חושפים API חיצוני ותקשורת ההפעלה שלהם היא **אך ורק** דרך האזנה ל-Kafka.  
6.   
7. **שמות קבצים קבועים:**  
   * כל שירות המייצר קובץ פלט **חייב** להשתמש בשם קבוע ומוגדר מראש. ההבחנה בין שירים שונים תתבצע על ידי תיקיית האב, שהיא ה-video\_id.  
     * קובץ מקור: original.mp3  
     * קובץ ללא שירה: vocals\_removed.mp3  
     * קובץ כתוביות: lyrics.lrc  
   *   
8.   
9. **הגדרת "שיר מוכן":**  
   * שיר נחשב "מוכן" אם ורק אם במסמך ה-Elasticsearch שלו, תחת האובייקט file\_paths, **קיימים שני שדות תקינים (לא ריקים)**: vocals\_removed ו-lyrics.  
   * **אין** להסתמך על שדה status כללי כדי לקבוע אם שיר מוכן.  
10.   
    ---

### **חלק ב': תזרים העבודה המלא והמחייב**

זהו התהליך המדויק, שלב אחר שלב, שיש ליישם:

1. **חיפוש:**  
   * **קלט:** Streamlit Client שולח שאילתת טקסט ל-API Server (POST /search).  
   * **תהליך:** API Server מעביר את הבקשה ב-HTTP ל-YouTube Service. YouTube Service פונה ל-YouTube API.  
   * **פלט:** YouTube Service מחזיר רשימת תוצאות JSON ל-API Server, והוא מחזירה ללקוח.  
2.   
3. **בקשת הורדה ותחילת עיבוד:**  
   * **קלט:** Streamlit Client שולח את פרטי השיר הנבחר ל-API Server (POST /download).  
   * **תהליך:**  
     1. API Server מעביר את הבקשה במלואה ב-HTTP ל-YouTube Service (POST /download).  
     2. YouTube Service מקבל את הבקשה ומייד מחזיר תגובת 202 Accepted בחזרה ל-API Server וללקוח.  
     3. **באופן א-סינכרוני,**   
        * **יוצר מסמך** חדש ב-Elasticsearch עם status: "downloading".  
        * **מוריד** את קובץ האודיו המקורי מ-YouTube.  
        * **שומר** את הקובץ בנתיב: shared/audio/{video\_id}/original.mp3.  
        * **מעדכן את המסמך** ב-Elasticsearch: משנה status ל-"processing" ומוסיף את הנתיב תחת file\_paths.original.  
        * **מפרסם 3 הודעות ל-Kafka** (המכילות video\_id בלבד):  
          1. אירוע לטופיק song.downloaded.  
          2. פקודה לטופיק audio.process.requested.  
          3. פקודה לטופיק transcription.process.requested.  
        *   
     4.   
   *   
4.   
5. **עיבוד אודיו ותמלול (במקביל):**  
   * **קלט:** Audio Service ו-Transcription Service מאזינים כל אחד לטופיק הפקודות שלו ומקבלים הודעה עם video\_id.  
   * **תהליך (זהה לשני השירותים):**  
     1. השירות פונה ל-Elasticsearch עם ה-video\_id שקיבל.  
     2. הוא **שולף** מהמסמך את נתיב הקובץ file\_paths.original.  
     3. הוא קורא את הקובץ מה-Shared Storage ומבצע את משימת העיבוד שלו.  
     4. הוא **שומר** את קובץ הפלט תחת אותה תיקיית video\_id עם השם הקבוע שלו (vocals\_removed.mp3 או lyrics.lrc).  
     5. הוא **מעדכן את המסמך** ב-Elasticsearch ומוסיף את נתיב קובץ הפלט שלו תחת file\_paths.  
   *   
   * **פלט:** כל שירות שולח אירוע ל-Kafka המציין את סיום עבודתו (audio.vocals\_processed, transcription.done).  
6.   
7. **הצגה והורדת התוצרים:**  
   * **קלט:** Streamlit Client מבצע polling תקופתי ל-API Server (GET /songs/{video\_id}/status).  
   * **תהליך:** API Server פונה ל-Elasticsearch, בודק את קיום שני נתיבי הפלט ב-file\_paths ומחשב את סטטוס ההתקדמות.  
   * **פלט:**  
     1. כאשר שני הקבצים קיימים, ה-API מחזיר files\_ready: true והלקוח מציג את השיר כמוכן.  
     2. המשתמש לוחץ "נגן", והלקוח שולח בקשה ל-API Server (GET /songs/{video\_id}/download).  
     3. API Server שולף את שני נתיבי הקבצים מ-Elasticsearch, קורא את הקבצים מה-Shared Storage, אורז אותם ל-ZIP, ומזרים אותו בחזרה ללקוח.  
   *   
8.   
   ---

### **חלק ג': מנדט ותחומי אחריות לכל שירות**

* **API Server:**  
  * **תפקיד:** שער כניסה (Gateway) בלבד.  
  * **קלט:** בקשות HTTP מ-Streamlit.  
  * **פלט:** תגובות JSON או קבצי ZIP ל-Streamlit.  
  * **אחריות:** ניתוב בקשות, שליפת מידע *לקריאה בלבד* מ-Elasticsearch.  
  * **איסורים:** **אינו** יוצר מסמכים, **אינו** שולח הודעות Kafka כחלק מתהליך ההורדה, **אינו** ניגש ישירות לקבצים לצורך עיבוד (רק לצורך אריזה ל-ZIP).  
*   
* **YouTube Service:**  
  * **תפקיד:** מתזמר תהליך ההורדה (Download Orchestrator).  
  * **קלט:** בקשות HTTP מ-API Server.  
  * **פלט:** תגובות HTTP ל-API Server, יצירה ועדכון של מסמכים ב-Elasticsearch, שליחת הודעות Kafka.  
  * **אחריות:** חיפוש ב-YouTube, יצירת המסמך הראשוני, הורדת קובץ המקור, והפעלת שרשרת העיבוד באמצעות Kafka.  
  * **איסורים:** **אינו** מאזין ל-Kafka כדי לקבל משימות.  
*   
* **Audio Processing / Transcription Service:**  
  * **תפקיד:** עובד (Worker).  
  * **קלט:** הודעות Kafka עם video\_id.  
  * **פלט:** קובץ מעובד ב-Shared Storage ועדכון מסמך ב-Elasticsearch.  
  * **אחריות:** לבצע משימה אחת ספציפית, לשלוף את המידע הדרוש לו מ-Elasticsearch, ולדווח על סיום עבודתו.  
  * **איסורים:** **אינו** חושף API חיצוני.  
*   
* **Streamlit Client:**  
  * **תפקיד:** ממשק משתמש.  
  * **קלט:** אינטראקציות משתמש.  
  * **פלט:** בקשות HTTP ל-API Server.  
  * **אחריות:** הצגת מידע, קבלת קלט מהמשתמש.  
  * **איסורים:** **אינו** מתקשר עם אף שירות אחר מלבד ה-API Server.

